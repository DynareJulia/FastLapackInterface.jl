var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Overview of all documented structures and functions.","category":"page"},{"location":"workspaces/#WorkSpaces","page":"Work Spaces","title":"Workspaces","text":"","category":"section"},{"location":"workspaces/","page":"Work Spaces","title":"Work Spaces","text":"Workspaces represent the buffers and temporary storage that are used during the computations of LAPACK functions. Upon initialization with a template matrix, work buffers will be allocated that are appropriate to be used during the factorization of matrices similar to the template, e.g. both Float64 and Float32 Matrices work, but also Complex numbers are allowed when appropriate.","category":"page"},{"location":"workspaces/#Workspace","page":"Work Spaces","title":"Workspace","text":"","category":"section"},{"location":"workspaces/","page":"Work Spaces","title":"Work Spaces","text":"The following convenience function is supplied in order to construct the correct Workspace for a given LAPACK function. This can then be used to perform the decompositions without extra allocations.","category":"page"},{"location":"workspaces/#FastLapackInterface.Workspace","page":"Work Spaces","title":"FastLapackInterface.Workspace","text":"Workspace(lapack_function, A)\n\nWill create the correct Workspace for the target lapack_function and matrix A.\n\nExamples\n\njulia> A = [1.2 2.3\n            6.2 3.3]\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\njulia> ws = Workspace(LAPACK.geqrt!, A)\nQRWYWs{Float64, Matrix{Float64}}\n  work: 4-element Vector{Float64}\n  T: 2×2 Matrix{Float64}\n\n\njulia> LinearAlgebra.QRCompactWY(factorize!(ws, A)...)\nLinearAlgebra.QRCompactWY{Float64, Matrix{Float64}, Matrix{Float64}}\nQ factor: 2×2 LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}, Matrix{Float64}}\nR factor:\n2×2 Matrix{Float64}:\n -6.31506  -3.67692\n  0.0      -1.63102\n\n\n\n\n\n","category":"type"},{"location":"workspaces/","page":"Work Spaces","title":"Work Spaces","text":"Each Workspace also has a function to resize! to allow for its use with larger matrices or with more features (e.g. the computation of left eigenvectors and right eigenvectors using EigenWs).","category":"page"},{"location":"workspaces/#Base.resize!-Tuple{Workspace, AbstractMatrix}","page":"Work Spaces","title":"Base.resize!","text":"resize!(ws, A; kwargs...)\n\nResizes the ws to be appropriate for use with matrix A. The kwargs can be used to communicate which features should be supported by the Workspace, such as left and right eigenvectors while using EigenWs. This function is mainly used for automatic resizing inside LAPACK functions.\n\n\n\n\n\n","category":"method"},{"location":"workspaces/#BunchKaufman-id","page":"Work Spaces","title":"BunchKaufman","text":"","category":"section"},{"location":"workspaces/#FastLapackInterface.BunchKaufmanWs","page":"Work Spaces","title":"FastLapackInterface.BunchKaufmanWs","text":"BunchKaufmanWs\n\nWorkspace for LinearAlgebra.BunchKaufman factorization using the LAPACK.sytrf! or LAPACK.sytrf_rook! functions for symmetric matrices, and LAPACK.hetrf! or LAPACK.hetrf_rook! functions for hermitian matrices (e.g. with ComplexF64 or ComplexF32 elements).\n\nExamples\n\njulia> A = [1.2 7.8\n            7.8 3.3]\n2×2 Matrix{Float64}:\n 1.2  7.8\n 7.8  3.3\n\njulia> ws = BunchKaufmanWs(A)\nBunchKaufmanWs{Float64}\n  work: 128-element Vector{Float64}\n  ipiv: 2-element Vector{Int64}\n\n\njulia> A, ipiv, info = LAPACK.sytrf!(ws, 'U', A)\n([1.2 7.8; 7.8 3.3], [-1, -1], 0)\n\njulia> t = LinearAlgebra.BunchKaufman(A, ipiv,'U', true, false, info)\nBunchKaufman{Float64, Matrix{Float64}, Vector{Int64}}\nD factor:\n2×2 Tridiagonal{Float64, Vector{Float64}}:\n 1.2  7.8\n 7.8  3.3\nU factor:\n2×2 UnitUpperTriangular{Float64, Matrix{Float64}}:\n 1.0  0.0\n  ⋅   1.0\npermutation:\n2-element Vector{Int64}:\n 1\n 2\n\njulia> A = [1.2 7.8\n            7.8 3.3]\n2×2 Matrix{Float64}:\n 1.2  7.8\n 7.8  3.3\n\njulia> ws = BunchKaufmanWs(A)\nBunchKaufmanWs{Float64}\n  work: 128-element Vector{Float64}\n  ipiv: 2-element Vector{Int64}\n\n\njulia> A, ipiv, info = LAPACK.sytrf_rook!(ws, 'U', A)\n([1.2 7.8; 7.8 3.3], [-1, -2], 0)\n\njulia> t = LinearAlgebra.BunchKaufman(A, ipiv,'U', true, true, info)\nBunchKaufman{Float64, Matrix{Float64}, Vector{Int64}}\nD factor:\n2×2 Tridiagonal{Float64, Vector{Float64}}:\n 1.2  7.8\n 7.8  3.3\nU factor:\n2×2 UnitUpperTriangular{Float64, Matrix{Float64}}:\n 1.0  0.0\n  ⋅   1.0\npermutation:\n2-element Vector{Int64}:\n 1\n 2\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#Cholesky-id","page":"Work Spaces","title":"Cholesky","text":"","category":"section"},{"location":"workspaces/#FastLapackInterface.CholeskyPivotedWs","page":"Work Spaces","title":"FastLapackInterface.CholeskyPivotedWs","text":"CholeskyPivotedWs\n\nWorkspace for LinearAlgebra.CholeskyPivoted factorization using the LAPACK.pstrf! function. The standard LinearAlgebra.Cholesky uses LAPACK.potrf! which is non-allocating and does not require a separate Workspace.\n\nExamples\n\njulia> A = [1.2 7.8\n            7.8 3.3]\n2×2 Matrix{Float64}:\n 1.2  7.8\n 7.8  3.3\n\njulia> ws = CholeskyPivotedWs(A)\nCholeskyPivotedWs{Float64}\n  work: 4-element Vector{Float64}\n  piv: 2-element Vector{Int64}\n\n\njulia> AA, piv, rank, info = LAPACK.pstrf!(ws, 'U', A, 1e-6)\n([1.816590212458495 4.293758683992806; 7.8 -17.236363636363635], [2, 1], 1, 1)\n\njulia> CholeskyPivoted(AA, 'U', piv, rank, 1e-6, info)\nCholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}\nU factor with rank 1:\n2×2 UpperTriangular{Float64, Matrix{Float64}}:\n 1.81659    4.29376\n  ⋅       -17.2364\npermutation:\n2-element Vector{Int64}:\n 2\n 1\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#Eigen-id","page":"Work Spaces","title":"Eigen","text":"","category":"section"},{"location":"workspaces/#FastLapackInterface.EigenWs","page":"Work Spaces","title":"FastLapackInterface.EigenWs","text":"EigenWs\n\nWorkspace for LinearAlgebra.Eigen factorization using the LAPACK.geevx! function.\n\nExamples\n\njulia> A = [1.2 2.3\n            6.2 3.3]\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\njulia> ws = EigenWs(A, rvecs=true)\nEigenWs{Float64, Matrix{Float64}, Float64}\n  work: 260-element Vector{Float64}\n  rwork: 2-element Vector{Float64}\n  VL: 0×2 Matrix{Float64}\n  VR: 2×2 Matrix{Float64}\n  W: 2-element Vector{Float64}\n  scale: 2-element Vector{Float64}\n  iwork: 0-element Vector{Int64}\n  rconde: 0-element Vector{Float64}\n  rcondv: 0-element Vector{Float64}\n\n\njulia> t = LAPACK.geevx!(ws, 'N', 'N', 'V', 'N', A);\n\njulia> LinearAlgebra.Eigen(t[2], t[5])\nEigen{Float64, Float64, Matrix{Float64}, Vector{Float64}}\nvalues:\n2-element Vector{Float64}:\n -1.6695025194532018\n  6.169502519453203\nvectors:\n2×2 Matrix{Float64}:\n -0.625424  -0.420019\n  0.780285  -0.907515\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#FastLapackInterface.HermitianEigenWs","page":"Work Spaces","title":"FastLapackInterface.HermitianEigenWs","text":"HermitianEigenWs\n\nWorkspace to be used with Hermitian diagonalization using the LAPACK.syevr! function. Supports both Real and Complex Hermitian matrices.\n\nExamples\n\njulia> A = [1.2 2.3\n            6.2 3.3]\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\njulia> ws = HermitianEigenWs(A, vecs=true)\nHermitianEigenWs{Float64, Matrix{Float64}, Float64}\n  work: 66-element Vector{Float64}\n  rwork: 0-element Vector{Float64}\n  iwork: 20-element Vector{Int64}\n  w: 2-element Vector{Float64}\n  Z: 2×2 Matrix{Float64}\n  isuppz: 4-element Vector{Int64}\n\n\njulia> LinearAlgebra.Eigen(LAPACK.syevr!(ws, 'V', 'A', 'U', A, 0.0, 0.0, 0, 0, 1e-6)...)\nEigen{Float64, Float64, Matrix{Float64}, Vector{Float64}}\nvalues:\n2-element Vector{Float64}:\n -0.2783393759541063\n  4.778339375954106\nvectors:\n2×2 Matrix{Float64}:\n -0.841217  0.540698\n  0.540698  0.841217\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#FastLapackInterface.GeneralizedEigenWs","page":"Work Spaces","title":"FastLapackInterface.GeneralizedEigenWs","text":"GeneralizedEigenWs\n\nWorkspace that can be used for LinearAlgebra.GeneralizedEigen factorization using LAPACK.ggev!. Supports Real and Complex matrices.\n\nExamples\n\njulia> A = [1.2 2.3\n            6.2 3.3]\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\njulia> B = [8.2 1.7\n            5.9 2.1]\n2×2 Matrix{Float64}:\n 8.2  1.7\n 5.9  2.1\n\njulia> ws = GeneralizedEigenWs(A, rvecs=true)\nGeneralizedEigenWs{Float64, Matrix{Float64}, Float64}\n  work: 78-element Vector{Float64}\n  vl: 0×2 Matrix{Float64}\n  vr: 2×2 Matrix{Float64}\n  αr: 2-element Vector{Float64}\n  αi: 2-element Vector{Float64}\n  β: 2-element Vector{Float64}\n\n\njulia> αr, αi, β, _, vr = LAPACK.ggev!(ws, 'N', 'V', A, B);\n\njulia> LinearAlgebra.GeneralizedEigen(αr ./ β, vr)\nGeneralizedEigen{Float64, Float64, Matrix{Float64}, Vector{Float64}}\nvalues:\n2-element Vector{Float64}:\n -0.8754932558185097\n  1.6362721153456299\nvectors:\n2×2 Matrix{Float64}:\n -0.452121  -0.0394242\n  1.0        1.0\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#LSE-id","page":"Work Spaces","title":"LSE","text":"","category":"section"},{"location":"workspaces/#FastLapackInterface.LSEWs","page":"Work Spaces","title":"FastLapackInterface.LSEWs","text":"LSEWs\n\nWorkspace for the least squares solving function LAPACK.geqrf!.\n\nExamples\n\njulia> A = [1.2 2.3 6.2\n            6.2 3.3 8.8\n            9.1 2.1 5.5]\n3×3 Matrix{Float64}:\n 1.2  2.3  6.2\n 6.2  3.3  8.8\n 9.1  2.1  5.5\n\njulia> B = [2.7 3.1 7.7\n            4.1 8.1 1.8]\n2×3 Matrix{Float64}:\n 2.7  3.1  7.7\n 4.1  8.1  1.8\n\njulia> c = [0.2, 7.2, 2.9]\n3-element Vector{Float64}:\n 0.2\n 7.2\n 2.9\n\njulia> d = [3.9, 2.1]\n2-element Vector{Float64}:\n 3.9\n 2.1\n\njulia> ws = LSEWs(A, B)\nLSEWs{Float64}\n  work: 101-element Vector{Float64}\n  X: 3-element Vector{Float64}\n\njulia> LAPACK.gglse!(ws, A, c, B, d)\n([0.19723156207005318, 0.0683561362406917, 0.40981438442398854], 13.750943845251626)\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#LU-id","page":"Work Spaces","title":"LU","text":"","category":"section"},{"location":"workspaces/#FastLapackInterface.LUWs","page":"Work Spaces","title":"FastLapackInterface.LUWs","text":"LUWs\n\nWorkspace to be used with the LinearAlgebra.LU representation of the LU factorization which uses the LAPACK.getrf! function.\n\nExamples\n\njulia> A = [1.2 2.3\n            6.2 3.3]\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\njulia> ws = LUWs(A)\nLUWs\n  ipiv: 2-element Vector{Int64}\n\njulia> t = LU(LAPACK.getrf!(ws, A)...)\nLU{Float64, Matrix{Float64}, Vector{Int64}}\nL factor:\n2×2 Matrix{Float64}:\n 1.0       0.0\n 0.193548  1.0\nU factor:\n2×2 Matrix{Float64}:\n 6.2  3.3\n 0.0  1.66129\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#QR-id","page":"Work Spaces","title":"QR","text":"","category":"section"},{"location":"workspaces/#FastLapackInterface.QRWs","page":"Work Spaces","title":"FastLapackInterface.QRWs","text":"QRWs\n\nWorkspace for standard LinearAlgebra.QR factorization using the LAPACK.geqrf! function.\n\nExamples\n\njulia> A = [1.2 2.3\n            6.2 3.3]\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\njulia> ws = QRWs(A)\nQRWs{Float64}\n  work: 64-element Vector{Float64}\n  τ: 2-element Vector{Float64}\n\njulia> t = QR(LAPACK.geqrf!(ws, A)...)\nQR{Float64, Matrix{Float64}, Vector{Float64}}\nQ factor: 2×2 LinearAlgebra.QRPackedQ{Float64, Matrix{Float64}, Vector{Float64}}\nR factor:\n2×2 Matrix{Float64}:\n -6.31506  -3.67692\n  0.0      -1.63102\n\njulia> Matrix(t)\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#FastLapackInterface.QRWYWs","page":"Work Spaces","title":"FastLapackInterface.QRWYWs","text":"QRWYWs\n\nWorkspace to be used with the LinearAlgebra.QRCompactWY representation of the blocked QR factorization which uses the LAPACK.geqrt! function. By default the blocksize for the algorithm is taken as min(36, min(size(template))), this can be overridden by using the blocksize keyword of the constructor.\n\nExamples\n\njulia> A = [1.2 2.3\n            6.2 3.3]\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\njulia> ws = QRWYWs(A)\nQRWYWs{Float64, Matrix{Float64}}\n  work: 4-element Vector{Float64}\n  T: 2×2 Matrix{Float64}\n\njulia> t = LinearAlgebra.QRCompactWY(LAPACK.geqrt!(ws, A)...)\nLinearAlgebra.QRCompactWY{Float64, Matrix{Float64}, Matrix{Float64}}\nQ factor: 2×2 LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}, Matrix{Float64}}\nR factor:\n2×2 Matrix{Float64}:\n -6.31506  -3.67692\n  0.0      -1.63102\n\njulia> Matrix(t)\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#FastLapackInterface.QRPivotedWs","page":"Work Spaces","title":"FastLapackInterface.QRPivotedWs","text":"QRPivotedWs\n\nWorkspace to be used with the LinearAlgebra.QRPivoted representation of the QR factorization which uses the LAPACK.geqp3! function.\n\nExamples\n\njulia> A = [1.2 2.3\n            6.2 3.3]\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\njulia> ws = QRPivotedWs(A)\nQRPivotedWs{Float64, Float64}\n  work: 100-element Vector{Float64}\n  rwork: 0-element Vector{Float64}\n  τ: 2-element Vector{Float64}\n  jpvt: 2-element Vector{Int64}\n\njulia> t = QRPivoted(LAPACK.geqp3!(ws, A)...)\nQRPivoted{Float64, Matrix{Float64}, Vector{Float64}, Vector{Int64}}\nQ factor: 2×2 LinearAlgebra.QRPackedQ{Float64, Matrix{Float64}, Vector{Float64}}\nR factor:\n2×2 Matrix{Float64}:\n -6.31506  -3.67692\n  0.0      -1.63102\npermutation:\n2-element Vector{Int64}:\n 1\n 2\n\njulia> Matrix(t)\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#FastLapackInterface.QROrmWs","page":"Work Spaces","title":"FastLapackInterface.QROrmWs","text":"QROrmWs\n\nWorkspace to be used with the LinearAlgebra.LAPACK.ormqr! function. It requires the workspace of a QR or a QRPivoted previous factorization\n\nExamples\n\n```jldoctest julia> A = [1.2 2.3             6.2 3.3] 2×2 Matrix{Float64}:  1.2  2.3  6.2  3.3\n\njulia> ws = QRPivotedWs(A) QRPivotedWs{Float64, Float64}   work: 100-element Vector{Float64}   rwork: 0-element Vector{Float64}   τ: 2-element Vector{Float64}   jpvt: 2-element Vector{Int64}\n\njulia> C=[1 0.5; 2 1] 2×2 Matrix{Float64}:  1.0  0.5  2.0  1.0\n\njulia> ormws =  QROrmWs(ws, 'L', 'N', A, C) QROrmWs{Float64}   work: 4224-element Vector{Float64}   τ: 2-element Vector{Float64}\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#FastLapackInterface.QROrgWs","page":"Work Spaces","title":"FastLapackInterface.QROrgWs","text":"QROrgWs\n\nWorkspace to be used with the LinearAlgebra.LAPACK.orgqr! function. It requires the workspace of a QR or a QRPivoted previous factorization\n\nExamples\n\n```jldoctest julia> A = [1.2 2.3             6.2 3.3] 2×2 Matrix{Float64}:  1.2  2.3  6.2  3.3\n\njulia> ws = QRPivotedWs(A) QRPivotedWs{Float64, Float64}   work: 100-element Vector{Float64}   rwork: 0-element Vector{Float64}   τ: 2-element Vector{Float64}   jpvt: 2-element Vector{Int64}\n\njulia> C=[1 0.5; 2 1] 2×2 Matrix{Float64}:  1.0  0.5  2.0  1.0\n\njulia> orgws =  QROrgWs(ws, 'L', 'N', A, C) QROrgWs{Float64}   work: 4224-element Vector{Float64}   τ: 2-element Vector{Float64}\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#Schur-id","page":"Work Spaces","title":"Schur","text":"","category":"section"},{"location":"workspaces/#FastLapackInterface.SchurWs","page":"Work Spaces","title":"FastLapackInterface.SchurWs","text":"SchurWs\n\nWorkspace to be used with the LinearAlgebra.Schur representation of the Schur decomposition which uses the LAPACK.gees! function.\n\nExamples\n\njulia> A = [1.2 2.3\n            6.2 3.3]\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\njulia> ws = SchurWs(A)\nSchurWs{Float64}\n  work: 68-element Vector{Float64}\n  wr: 2-element Vector{Float64}\n  wi: 2-element Vector{Float64}\n  vs: 2×2 Matrix{Float64}\n  sdim: Base.RefValue{Int64}\n  bwork: 2-element Vector{Int64}\n  eigen_values: 2-element Vector{ComplexF64}\n\njulia> t = Schur(LAPACK.gees!(ws, 'V', A)...)\nSchur{Float64, Matrix{Float64}, Vector{Float64}}\nT factor:\n2×2 Matrix{Float64}:\n -1.6695  -3.9\n  0.0      6.1695\nZ factor:\n2×2 Matrix{Float64}:\n -0.625424  -0.780285\n  0.780285  -0.625424\neigenvalues:\n2-element Vector{Float64}:\n -1.6695025194532018\n  6.169502519453203\n\njulia> Matrix(t)\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#FastLapackInterface.GeneralizedSchurWs","page":"Work Spaces","title":"FastLapackInterface.GeneralizedSchurWs","text":"GeneralizedSchurWs\n\nWorkspace to be used with the LinearAlgebra.GeneralizedSchur representation of the Generalized Schur decomposition which uses the LAPACK.gges! function.\n\nExamples\n\njulia> A = [1.2 2.3\n            6.2 3.3]\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\njulia> B = [8.2 0.3\n            1.7 4.3]\n2×2 Matrix{Float64}:\n 8.2  0.3\n 1.7  4.3\n\njulia> ws = GeneralizedSchurWs(A)\nGeneralizedSchurWs{Float64}\n  work: 90-element Vector{Float64}\n  αr: 2-element Vector{Float64}\n  αi: 2-element Vector{Float64}\n  β: 2-element Vector{Float64}\n  vsl: 2×2 Matrix{Float64}\n  vsr: 2×2 Matrix{Float64}\n  sdim: Base.RefValue{Int64}\n  bwork: 2-element Vector{Int64}\n  eigen_values: 2-element Vector{ComplexF64}\n  \njulia> t = GeneralizedSchur(LAPACK.gges!(ws, 'V','V', A, B)...)\nGeneralizedSchur{Float64, Matrix{Float64}, Vector{ComplexF64}, Vector{Float64}}\nS factor:\n2×2 Matrix{Float64}:\n -1.43796  1.63843\n  0.0      7.16295\nT factor:\n2×2 Matrix{Float64}:\n 5.06887  -4.00221\n 0.0       6.85558\nQ factor:\n2×2 Matrix{Float64}:\n -0.857329  0.514769\n  0.514769  0.857329\nZ factor:\n2×2 Matrix{Float64}:\n -0.560266  0.828313\n  0.828313  0.560266\nα:\n2-element Vector{ComplexF64}:\n -1.4379554610733563 + 0.0im\n   7.162947865097022 + 0.0im\nβ:\n2-element Vector{Float64}:\n 5.068865029631368\n 6.855578082442485\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#SVD-id","page":"Work Spaces","title":"SVD","text":"","category":"section"},{"location":"workspaces/#FastLapackInterface.SVDsddWs","page":"Work Spaces","title":"FastLapackInterface.SVDsddWs","text":"SVDsddWs\n\ncreates a workspace for LinearAlgebra.SVD factorization using the LAPACK.gesdd! function.\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#FastLapackInterface.SVDsddWs-Tuple{AbstractMatrix}","page":"Work Spaces","title":"FastLapackInterface.SVDsddWs","text":"SVDsddWs(A; job = 'A')\n\ncreates a workspace for LinearAlgebra.SVD factorization using the LAPACK.gesdd! function.\n\nArguments\n\nA::AbstractMatrix: the matrix to be decomposed. Only the shape of the matrix matters for building the workspace. The actual ellements value does not.\njob::AbstractChar: one of A, N, O or S. Default = 'A'. See gesdd!.\n\nExamples\n\njulia> A = [1.2 2.3\n            6.2 3.3]\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\njulia> ws = FastLapackInterface.SVDsddWs(A, job = 'A')\nSVDsddWs{Float64, Matrix{Float64}, Float64}\n  U: 2×2 Matrix{Float64}\n  VT: 2×2 Matrix{Float64}\n  work: 134-element Vector{Float64}\n  S: 2-element Vector{Float64}\n  rwork: 0-element Vector{Float64}\n  iwork: 16-element Vector{Int64}\n\njulia> t = FastLapackInterface.gesdd!(ws, 'A', A);\n\njulia> LinearAlgebra.SVD(t[1], t[2], t[3])\nSVD{Float64, Float64, Matrix{Float64}, Vector{Float64}}\nU factor:\n2×2 Matrix{Float64}:\n -0.302437  -0.953169\n -0.953169   0.302437\nsingular values:\n2-element Vector{Float64}:\n 7.355199814161389\n 1.400369841777625\nVt factor:\n2×2 Matrix{Float64}:\n -0.852808  -0.522224\n  0.522224  -0.852808\n\n\n\n\n\n","category":"method"},{"location":"workspaces/#FastLapackInterface.SVDsvdWs","page":"Work Spaces","title":"FastLapackInterface.SVDsvdWs","text":"SVDsvdWs\n\nWorkspace for LinearAlgebra.SVD factorization using the LAPACK.gesvd! function.\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#FastLapackInterface.SVDsvdWs-Tuple{AbstractMatrix}","page":"Work Spaces","title":"FastLapackInterface.SVDsvdWs","text":"SVDsvdWs(A; jobu = 'A', jobvt = 'A')\n\ncreates a workspace for LinearAlgebra.SVD factorization using the LAPACK.gesvd! function.\n\nArguments\n\nA::AbstractMatrix: the matrix to be decomposed. Only the shape of the matrix matters for building the workspace. The actual ellements value does not.\njobu::AbstractChar: one of A, N, O or S. Default = 'A'. See gesvd!.\njobvt::AbstractChar: one of A, N, O or S. Default = 'A'. See gesvd!.\n\nExamples\n\njulia> A = [1.2 2.3\n            6.2 3.3]\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\njulia> ws = SVDsvdWs(A, jobu = 'A', jobvt = 'A')\nSVDsvdWs{Float64, Matrix{Float64}, Float64}\n  U: 2×2 Matrix{Float64}\n  VT: 2×2 Matrix{Float64}\n  work: 134-element Vector{Float64}\n  S: 2-element Vector{Float64}\n  rwork: 0-element Vector{Float64}\n\njulia> t = FastLapackInterface.gesvd!(ws, 'A', 'A', A);\n\njulia> SVD(t[1], t[2], t[3])\nSVD{Float64, Float64, Matrix{Float64}, Vector{Float64}}\nU factor:\n2×2 Matrix{Float64}:\n -0.302437  -0.953169\n -0.953169   0.302437\nsingular values:\n2-element Vector{Float64}:\n 7.355199814161389\n 1.400369841777625\nVt factor:\n2×2 Matrix{Float64}:\n -0.852808  -0.522224\n  0.522224  -0.852808\n\n\n\n\n\n","category":"method"},{"location":"workspaces/#FastLapackInterface.GeneralizedSVDWs","page":"Work Spaces","title":"FastLapackInterface.GeneralizedSVDWs","text":"GeneralizedSVDWs\n\nWorkspace for LinearAlgebra.SVD factorization using the LAPACK.ggsvd3! function.\n\n\n\n\n\n","category":"type"},{"location":"workspaces/#FastLapackInterface.GeneralizedSVDWs-Tuple{AbstractMatrix}","page":"Work Spaces","title":"FastLapackInterface.GeneralizedSVDWs","text":"GeneralizedSVDWs(A::AbstractMatrix; jobu = 'U', jobv = 'V', jobq = 'Q')\n\ncreates a workspace for LinearAlgebra.SVD factorization using the LAPACK.ggsvd3! function.\n\nArguments\n\nA::AbstractMatrix: the matrix to be decomposed. Only the shape of the matrix matters for building the workspace. The actual ellements value does not.\njobu::AbstractChar: one of U or N. Default = 'U'. See ggsvd3!.\njobv::AbstractChar: one of V or N. Default = 'V'. See ggsvd3!.\njobq::AbstractChar: one of Q or N. Default = 'Q'. See ggsvd3!.\n\nArguments\n\nExamples\n\njulia> A = [1.2 2.3\n            6.2 3.3]\n2×2 Matrix{Float64}:\n 1.2  2.3\n 6.2  3.3\n\njulia> B = [2.2 3.3\n            5.2 4.3]\n2×2 Matrix{Float64}:\n 2.2  3.3\n 5.2  4.3\n\njulia> ws = GeneralizedSVDWs(A, B)\nGeneralizedSVDWs{Float64, Matrix{Float64}, Float64}\n  alpha: 2-element Vector{Float64}\n  beta: 2-element Vector{Float64}\n  U: 2×2 Matrix{Float64}\n  V: 2×2 Matrix{Float64}\n  Q: 2×2 Matrix{Float64}\n  work: 102-element Vector{Float64}\n  rwork: 0-element Vector{Float64}\n  iwork: 2-element Vector{Int64}\n\n\njulia> t = FastLapackInterface.ggsvd3!(ws, 'U', 'V', 'Q', A, B);\n\njulia> GeneralizedSVD(t...)\nGeneralizedSVD{Float64, Matrix{Float64}, Float64, Vector{Float64}}\nU factor:\n2×2 Matrix{Float64}:\n -0.309806  0.9508\n  0.9508    0.309806\nV factor:\n2×2 Matrix{Float64}:\n -0.653816  0.756653\n  0.756653  0.653816\nQ factor:\n2×2 Matrix{Float64}:\n  0.723532  0.690291\n -0.690291  0.723532\nD1 factor:\n2×2 Matrix{Float64}:\n 0.911256  0.0\n 0.0       0.517359\nD2 factor:\n2×2 Matrix{Float64}:\n 0.411841  0.0\n 0.0       0.855768\nR0 factor:\n2×2 Matrix{Float64}:\n 2.54834  6.10941\n 0.0      8.57328\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LAPACK","page":"LAPACK","title":"LAPACK","text":"","category":"section"},{"location":"LAPACK/","page":"LAPACK","title":"LAPACK","text":"This section details the LAPACK functions that are supported for use with various Workspaces. Each function has a resize keyword argument that is true by default, allowing for automatic resizing of the workspaces to accomodate larger or smaller Matrices or different features than they were originally constructed for. This is provided as a convenience but involves an efficiency cost. When working with matrices of different sizes, the best strategy is to successively apply a function to all matrices of the same size and to minimize triggering the resizing mechanism.","category":"page"},{"location":"LAPACK/#Unified-Interface","page":"LAPACK","title":"Unified Interface","text":"","category":"section"},{"location":"LAPACK/","page":"LAPACK","title":"LAPACK","text":"After having created the Workspace that corresponds to the targeted factorization or decomposition, one of the following two aliases can be used to dispatch the call to the correct LAPACK function.","category":"page"},{"location":"LAPACK/#FastLapackInterface.decompose!","page":"LAPACK","title":"FastLapackInterface.decompose!","text":"decompose!(ws, args...)\n\nWill use the previously created Workspace ws to dispatch to the correct LAPACK call.  \n\n\n\n\n\n","category":"function"},{"location":"LAPACK/#FastLapackInterface.factorize!","page":"LAPACK","title":"FastLapackInterface.factorize!","text":"factorize!(ws, args...)\n\nAlias for decompose!.\n\n\n\n\n\n","category":"function"},{"location":"LAPACK/#BunchKaufman","page":"LAPACK","title":"BunchKaufman","text":"","category":"section"},{"location":"LAPACK/#LinearAlgebra.LAPACK.sytrf!-Tuple{BunchKaufmanWs, AbstractChar, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.sytrf!","text":"sytrf!(ws, uplo, A; resize=true) -> (A, ws.ipiv, info)\n\nComputes the Bunch-Kaufman factorization of a symmetric matrix A, using previously allocated workspace ws. If the workspace was too small and resize==true it will automatically resized. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored.\n\nReturns A, overwritten by the factorization, a pivot vector ws.ipiv, and the error code info which is a non-negative integer. If info is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position info.\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LinearAlgebra.LAPACK.sytrf_rook!-Tuple{BunchKaufmanWs, AbstractChar, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.sytrf_rook!","text":"sytrf_rook!(ws, uplo, A; resize=true) -> (A, ws.ipiv, info)\n\nSimilar to sytrf! but using the bounded (\"rook\") diagonal pivoting method.\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LinearAlgebra.LAPACK.hetrf!-Tuple{BunchKaufmanWs, AbstractChar, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.hetrf!","text":"hetrf!(ws, uplo, A; resize=true) -> (A, ws.ipiv, info)\n\nSimilar as sytrf! but for Hermitian matrices.\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LinearAlgebra.LAPACK.hetrf_rook!-Tuple{BunchKaufmanWs, AbstractChar, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.hetrf_rook!","text":"hetrf_rook!(ws, uplo, A; resize=true) -> (A, ws.ipiv, info)\n\nSimilar to hetrf! but using the bounded (\"rook\") diagonal pivoting method.\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#Cholesky","page":"LAPACK","title":"Cholesky","text":"","category":"section"},{"location":"LAPACK/#LinearAlgebra.LAPACK.pstrf!-Tuple{CholeskyPivotedWs, AbstractChar, AbstractMatrix, Real}","page":"LAPACK","title":"LinearAlgebra.LAPACK.pstrf!","text":"pstrf!(ws, uplo, A, tol; resize=true) -> (A, ws.piv, rank, info)\n\nComputes the (upper if uplo = U, lower if uplo = L) pivoted Cholesky decomposition of positive-definite matrix A with a user-set tolerance tol, using a preallocated CholeskyPivotedWs. If the workspace was too small and resize==true it will be automatically resized. A is overwritten by its Cholesky decomposition.\n\nReturns A, the pivots piv, the rank of A, and an info code. If info = 0, the factorization succeeded. If info = i > 0, then A is indefinite or rank-deficient.\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#Eigen","page":"LAPACK","title":"Eigen","text":"","category":"section"},{"location":"LAPACK/#LinearAlgebra.LAPACK.geevx!-Tuple{EigenWs, AbstractChar, AbstractChar, AbstractChar, AbstractChar, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.geevx!","text":"geevx!(ws, balanc, jobvl, jobvr, sense, A; resize=true) -> (A, ws.W, [ws.rwork,] ws.VL, ws.VR, ilo, ihi, ws.scale, abnrm, ws.rconde, ws.rcondv)\n\nFinds the eigensystem of A with matrix balancing using a preallocated EigenWs. If jobvl = N, the left eigenvectors of A aren't computed. If jobvr = N, the right eigenvectors of A aren't computed. If jobvl = V or jobvr = V, the corresponding eigenvectors are computed. If balanc = N, no balancing is performed. If balanc = P, A is permuted but not scaled. If balanc = S, A is scaled but not permuted. If balanc = B, A is permuted and scaled. If sense = N, no reciprocal condition numbers are computed. If sense = E, reciprocal condition numbers are computed for the eigenvalues only. If sense = V, reciprocal condition numbers are computed for the right eigenvectors only. If sense = B, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If sense = E,B, the right and left eigenvectors must be computed. ws.rwork is only returned in the Real case. If ws does not have the appropriate size for A and the work to be done, if resize=true, it will be automatically resized accordingly. \n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LinearAlgebra.LAPACK.syevr!-Tuple{HermitianEigenWs, AbstractChar, AbstractChar, AbstractChar, AbstractMatrix, AbstractFloat, AbstractFloat, Integer, Integer, AbstractFloat}","page":"LAPACK","title":"LinearAlgebra.LAPACK.syevr!","text":"syevr!(ws, jobz, range, uplo, A, vl, vu, il, iu, abstol; resize=true) -> (ws.W, ws.Z)\n\nFinds the eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) of a symmetric matrix A using a preallocated HermitianEigenWs. If the workspace is not appropriate for A and resize==true it will be automatically resized. If uplo = U, the upper triangle of A is used. If uplo = L, the lower triangle of A is used. If range = A, all the eigenvalues are found. If range = V, the eigenvalues in the half-open interval (vl, vu] are found. If range = I, the eigenvalues with indices between il and iu are found. abstol can be set as a tolerance for convergence.\n\nThe eigenvalues are returned as ws.W and the eigenvectors in ws.Z.\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LinearAlgebra.LAPACK.ggev!-Tuple{GeneralizedEigenWs, AbstractChar, AbstractChar, AbstractMatrix, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.ggev!","text":"ggev!(ws, jobvl, jobvr, A, B; resize=true) -> (ws.αr, [ws.αi,], ws.β, ws.vl, ws.vr)\n\nFinds the generalized eigendecomposition of A and B usin a preallocated GeneralizedEigenWs. If the workspace is not appropriately sized and resize == true, it will automatically be resized. If jobvl = N, the left eigenvectors aren't computed. If jobvr = N, the right eigenvectors aren't computed. If jobvl = V or jobvr = V, the corresponding eigenvectors are computed. ws.αi is only returned in the Real case.\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LSE","page":"LAPACK","title":"LSE","text":"","category":"section"},{"location":"LAPACK/#LinearAlgebra.LAPACK.gglse!-Tuple{LSEWs, AbstractMatrix, AbstractVector, AbstractMatrix, AbstractVector}","page":"LAPACK","title":"LinearAlgebra.LAPACK.gglse!","text":"gglse!(ws, A, c, B, d) -> (ws.X,res)\n\nSolves the equation A * x = c where x is subject to the equality constraint B * x = d. Uses the formula ||c - A*x||^2 = 0 to solve. Uses preallocated LSEWs to store X and work buffers.  Returns ws.X and the residual sum-of-squares.\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LU","page":"LAPACK","title":"LU","text":"","category":"section"},{"location":"LAPACK/#LinearAlgebra.LAPACK.getrf!-Tuple{LUWs, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.getrf!","text":"getrf!(ws, A; resize=true) -> (A, ws.ipiv, info)\n\nCompute the pivoted LU factorization of A, A = LU, using the preallocated LUWs workspace ws. If the workspace is too small and resize==true it will be resized appropriately for A.\n\nReturns A, modified in-place, ws.ipiv, the pivoting information, and the ws.info code which indicates success (info = 0), a singular value in U (info = i, in which case U[i,i] is singular), or an error code (info < 0).\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LinearAlgebra.LAPACK.getrs!-Tuple{LUWs, AbstractChar, AbstractMatrix, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.getrs!","text":"getrs!(ws, trans, A, B)\n\nSolves the linear equation A * X = B, transpose(A) * X = B, or adjoint(A) * X = B for square A. Modifies the matrix/vector B in place with the solution. A is the LU factorization from getrf! with the pivoting information stored in ws.ipiv. trans may be one of N (no modification), T (transpose), or C (conjugate transpose).\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#QR","page":"LAPACK","title":"QR","text":"","category":"section"},{"location":"LAPACK/#LinearAlgebra.LAPACK.geqrf!-Tuple{QRWs, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.geqrf!","text":"geqrf!(ws, A; resize=true) -> (A, ws.τ)\n\nCompute the QR factorization of A, A = QR, using previously allocated QRWs workspace ws. ws.τ contains scalars which parameterize the elementary reflectors of the factorization. ws.τ must have length greater than or equal to the smallest dimension of A. If this is not the case, and resize==true the workspace will be automatically resized to the appropriate size.\n\nA and ws.τ modified in-place.\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LinearAlgebra.LAPACK.geqrt!-Tuple{QRWYWs, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.geqrt!","text":"geqrt!(ws, A; resize=true) -> (A, ws.T)\n\nCompute the blocked QR factorization of A, A = QR, using a preallocated QRWYWs workspace ws. ws.T contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of ws.T sets the block size and it must satisfy 1 <= size(ws.T, 1) <= min(size(A)...). The second dimension of T must equal the smallest dimension of A, i.e. size(ws.T, 2) == size(A, 2). If this is not the case and resize==true, the workspace will automatically be resized to the appropriate dimensions.\n\nA and ws.T are modified in-place.\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LinearAlgebra.LAPACK.geqp3!-Tuple{QRPivotedWs, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.geqp3!","text":"geqp3!(ws, A; resize=true) -> (A, ws.τ, ws.jpvt)\n\nCompute the pivoted QR factorization of A, AP = QR using BLAS level 3, using the preallocated QRPivotedWs workspace ws. P is a pivoting matrix, represented by ws.jpvt. ws.τ stores the elementary reflectors. ws.jpvt must have length greater than or equal to n if A is an (m x n) matrix and ws.τ must have length greater than or equal to the smallest dimension of A. If this is not the case and resize == true the workspace will be appropriately resized.\n\nA, ws.jpvt, and ws.τ are modified in-place.\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LinearAlgebra.LAPACK.ormqr!-Tuple{QROrmWs, AbstractChar, AbstractChar, AbstractMatrix, AbstractVecOrMat}","page":"LAPACK","title":"LinearAlgebra.LAPACK.ormqr!","text":"ormqr!(ws, side, trans, A, C) -> C\n\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a QR factorization of A. Uses preallocated workspace ws::QROrmWs and the factors are assumed to be stored in ws.τ. C is overwritten.\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LinearAlgebra.LAPACK.orgqr!-Tuple{QRWs, AbstractMatrix, Integer}","page":"LAPACK","title":"LinearAlgebra.LAPACK.orgqr!","text":"orgqr!(ws, A, k = length(tau))\n\nExplicitly finds the matrix Q of a QR factorization using the factors stored in ws.τ, that were generated from calling  geqrf! if ws is a QRWs or geqp3! if ws is a QRPivotedWs. A is overwritten by Q.\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#Schur","page":"LAPACK","title":"Schur","text":"","category":"section"},{"location":"LAPACK/#LinearAlgebra.LAPACK.gees!-Tuple{SchurWs, AbstractChar, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.gees!","text":"gees!(ws, jobvs, A; select=nothing, criterium=0.0, resize=true) -> (A, vs, ws.eigen_values)\n\nComputes the eigenvalues (jobvs = N) or the eigenvalues and Schur vectors (jobvs = V) of matrix A, using the preallocated SchurWs worspace ws. If ws is not of the appropriate size and resize==true it will be resized for A.  A is overwritten by its Schur form, and ws.eigen_values is overwritten with the eigenvalues.\n\nIt is possible to select the eigenvalues appearing in the top left corner of the Schur form:\n\nby setting the select option to one of \nlp: Left plane (real(eigenvalue) < criterium)\nrp: Right plane (real(eigenvalue) >= criterium)\nid: Interior of disk (abs(eigenvalue)^2 < criterium) \ned: Exterior of disk (abs(eigenvalue)^2 >= criterium)\nand setting criterium.\nby setting select equal to a function used to sort the eigenvalues during the decomponsition. In this case, the criterium keyword isn't used. The function should have the signature f(wr::T, wi::T) -> Bool, where wr and wi are the real and imaginary parts of the eigenvalue, and T == eltype(A). This is not available on aarch64 architecture.\n\nReturns A, vs containing the Schur vectors, and ws.eigen_values.\n\nSee also FastLapackInterface.SCHURORDER\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LinearAlgebra.LAPACK.gges!-Tuple{GeneralizedSchurWs, AbstractChar, AbstractChar, AbstractMatrix, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.gges!","text":"gges!(ws, jobvsl, jobvsr, A, B; select=nothing, criterium = 0, resize=true) -> (A, B, ws.α, ws.β, ws.vsl, ws.vsr)\n\nComputes the generalized eigenvalues, generalized Schur form, left Schur vectors (jobsvl = V), or right Schur vectors (jobvsr = V) of A and B, using preallocated GeneralizedSchurWs workspace ws. If ws is not of the right size, and resize==true it will be resized appropriately.\n\nIt is possible to select the eigenvalues appearing in the top left corner of the Schur form:\n\nby setting the select option to one of \nlp: Left plane (real(eigenvalue) < criterium)\nrp: Right plane (real(eigenvalue) >= criterium)\nid: Interior of disk (abs(eigenvalue)^2 < criterium) \ned: Exterior of disk (abs(eigenvalue)^2 >= criterium)\nand setting criterium.\nby setting select equal to a function used to sort the eigenvalues during the decomposition. In this case, the criterium keyword isn't used. The function should have the signature f(αr::T, αi::T, β::T) -> Bool where T == eltype(A). An eigenvalue (αr[j]+αi[j])/β[j] is selected if f(αr[j],αi[j],β[j]) is true, i.e. if either one of a complex conjugate pair of eigenvalues is selected, then both complex eigenvalues are selected. This is not available on aarch64 architecture.\n\nThe generalized eigenvalues components are returned in ws.α and ws.β where ws.α is a complex vector and ẁs.β, a real vector. The generalized eigenvalues (ws.α./ws.β) are returned in ws.eigen_values, a complex vector.  The left Schur vectors are returned in ws.vsl and the right Schur vectors are returned in ws.vsr.\n\nSee also FastLapackInterface.SCHURORDER\n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#FastLapackInterface.SCHURORDER","page":"LAPACK","title":"FastLapackInterface.SCHURORDER","text":"enum SCHURORDER lp rp id ed\n\nKeywords\n\n- `lp`: Left plane (real(eigenvalue) < criterium)\n- `rp`: Right plane (real(eigenvalue) >= criterium)\n- `id`: Interior of disk (abs(eigenvalue)^2 < criterium) \n- `ed`: Exterior of disk (abs(eigenvalue)^2 >= criterium)\n\nNote\n\n- the left half-plane is obtained with criterium = 0\n- the unit disk is obtained with criterium = 1\n- because of numerical error in computing repeated eigenvalues, you need to adapt\n  criterium depending whether you want to include or not 0 is the left half-plane or\n  1 in the unit disk\n- criterium is passed as optional parameter to `gees` and `gges` functions\n\n\n\n\n\n","category":"type"},{"location":"LAPACK/#SVD","page":"LAPACK","title":"SVD","text":"","category":"section"},{"location":"LAPACK/#LinearAlgebra.LAPACK.gesdd!-Tuple{SVDsddWs, AbstractChar, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.gesdd!","text":"gesdd!(ws, job, A; resize = true) -> (U, S, VT)\n\nFinds the singular value decomposition of A, A = U * S * V', using a divide and conquer approachusing a preallocated SVDsddWs. If job : A, all the columns of U and the rows of V' are computed. If job = N, no columns of U or rows of V' are computed. If job = O, A is overwritten with the columns of (thin) U and the rows of (thin) V'. If job = S, the columns of (thin) U and the rows of (thin) V' are computed and returned separately. The value of job must be the same in SVDsddWs and in 'gesdd!. Ifwsdoes not have the appropriate size forAand the work to be done, ifresize=true`, it will be automatically resized accordingly. \n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LinearAlgebra.LAPACK.gesvd!-Tuple{SVDsvdWs, AbstractChar, AbstractChar, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.gesvd!","text":"gesvd!(ws, jobu, jobvt, A; resize = true) -> (U, S, VT)\n\nFinds the singular value decomposition of A, A = U * S * V' using a preallocated SVDsvdWs. If jobu = A, all the columns of U are computed. If jobvt = A all the rows of V' are computed. If jobu = N, no columns of U are computed. If jobvt = N no rows of V' are computed. If jobu = O, A is overwritten with the columns of (thin) U. If jobvt = O, A is overwritten with the rows of (thin) V'. If jobu = S, the columns of (thin) U are computed and returned separately. If jobvt = S the rows of (thin) V' are computed and returned separately. jobu and jobvt can't both be O. The value of jobu and jobvt must be the same in SVDsvdWs and in gesvd!\n\nReturns U, S, and Vt, where S are the singular values of A. If ws does not have the appropriate size for A and the work to be done, if resize=true, it will be automatically resized accordingly. \n\n\n\n\n\n","category":"method"},{"location":"LAPACK/#LinearAlgebra.LAPACK.ggsvd3!-Tuple{GeneralizedSVDWs, AbstractChar, AbstractChar, AbstractChar, AbstractMatrix, AbstractMatrix}","page":"LAPACK","title":"LinearAlgebra.LAPACK.ggsvd3!","text":"ggsvd3!(ws, jobu, jobv, jobq, A, B; resize = true) -> (U, V, Q, alpha, beta, k, l, R)\n\nFinds the generalized singular value decomposition of A and B, U'*A*Q = D1*R and V'*B*Q = D2*R, using a preallocated GeneralizedSVDWs. D1 has alpha on its diagonal and D2 has beta on its diagonal. If jobu = U, the orthogonal/unitary matrix U is computed. If jobv = V the orthogonal/unitary matrix V is computed. If jobq = Q, the orthogonal/unitary matrix Q is computed. If jobu, jobv, or jobq is N, that matrix is not computed. The value of jobu, jobv and jobq must be the same in GeneralizedSVDWs and ggsvd3!. This function requires LAPACK 3.6.0. If ws does not have the appropriate size for A, B, and the work to be done, if resize=true, it will be automatically resized accordingly. \n\n\n\n\n\n","category":"method"},{"location":"#man-fastlapack","page":"Home","title":"Fast Lapack Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of FastLapackInterface is to eliminate any temporary allocations when using certain LAPACK functions compared to Base julia. This is achieved by providing some Workspaces that can then be used during the computation of LAPACK functions. Eliminating most of the allocations not only improves the computation time of the functions, but dramatically improves GC impact when performing multithreaded workloads.","category":"page"}]
}
